import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as t}from"./app-B3SZc_3K.js";const o={};function p(i,n){return t(),a("div",null,n[0]||(n[0]=[e(`<p>Data is the lifeblood of most applications. Whether it&#39;s coming from a database, an API, or a service layer, Stone.js gives you multiple ways to fetch, inject, and reuse data, across both frontend and backend, without duplicating logic or coupling view to infrastructure.</p><p>This page explores how to handle data fetching properly in a Stone.js + React application, across:</p><ul><li>Page handlers</li><li>Middleware</li><li>Components</li><li>SSR with snapshots</li></ul><p>All while staying consistent with the Continuum Architecture.</p><h2 id="fetching-data-in-handle-the-standard-way" tabindex="-1"><a class="header-anchor" href="#fetching-data-in-handle-the-standard-way"><span>Fetching data in <code>handle()</code> (the standard way)</span></a></h2><p>The primary and recommended place to fetch data is inside the <code>handle()</code> method of a page. This method runs in the <strong>Stone.js lifecycle</strong> and is designed to process the incoming event, validate, call services, and return a structured result.</p><p>That result will then be passed to the <code>render()</code> method.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">async</span> <span class="token function">handle</span><span class="token punctuation">(</span>event<span class="token operator">:</span> ReactIncomingEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> userId <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;userId&#39;</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You can return:</p><ul><li><code>undefined</code> (if nothing needs to be passed to the view)</li><li>Raw data (Stone.js will wrap it into a response)</li><li>A <code>ReactOutgoingResponse</code> for full control</li></ul><p>Returning data here ensures it can be snapshotted automatically in SSR mode.</p><h2 id="fetching-data-in-middleware" tabindex="-1"><a class="header-anchor" href="#fetching-data-in-middleware"><span>Fetching data in middleware</span></a></h2><p>Middleware runs before your page handler and can be used to:</p><ul><li>Check access or authentication</li><li>Preload user or context</li><li>Set up shared data across multiple routes</li></ul><p>When fetching data in middleware, you <strong>must return a full response</strong> using <code>reactResponse()</code> or <code>reactRedirectResponse()</code>. You can also use <code>reactRuntime.snapshot()</code> to persist data across SSR.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">AuthMiddleware</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> reactRuntime<span class="token punctuation">,</span> authService <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> reactRuntime<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> authService<span class="token punctuation">.</span><span class="token function">getCurrentUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    event<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This ensures the user is fetched once and hydrated properly on the client without re-calling the service.</p><p>For more informations about the snapshotting data, refer to the <a href="./snapshot">Snapshot</a> section.</p><h2 id="fetching-data-inside-components" tabindex="-1"><a class="header-anchor" href="#fetching-data-inside-components"><span>Fetching data inside components</span></a></h2><p>React components themselves can also fetch data, via <code>useEffect</code>, <code>useQuery</code>, or any other library. But be careful: this happens <strong>after the Stone.js lifecycle has ended</strong>.</p><p>That means:</p><ul><li>No automatic snapshotting</li><li>No server-side fetching (unless you replicate it)</li><li>Increased risk of duplicate fetches</li></ul><p>This is why Stone.js recommends keeping data fetching <strong>outside the component</strong> when possible, and <strong>passing it in as props</strong> via the <code>render()</code> method or via the <code>StoneContext</code>.</p><p>If you really must fetch inside the component:</p><ul><li>Use <code>useEffect()</code> responsibly</li><li>Wrap it in suspense if needed</li><li>Avoid coupling it with container services</li></ul><h2 id="snapshotting-data-ssr" tabindex="-1"><a class="header-anchor" href="#snapshotting-data-ssr"><span>Snapshotting Data (SSR)</span></a></h2><p>In Stone.js, a <strong>snapshot</strong> is a mechanism that captures and transfers data across execution dimensions, from server to browser, during SSR (Server-Side Rendering).</p><p>Imagine the lifecycle like this:</p><ol><li>Your page receives an incoming event (e.g. browser request)</li><li>It processes the request on the <strong>server</strong> and returns data</li><li>That data is serialized into the <strong>HTML response</strong></li><li>On the <strong>client</strong>, Stone.js restores the data to <strong>hydrate</strong> the page</li><li>The page renders, <strong>without fetching again</strong></li></ol><p>This mechanism is called a <strong>snapshot</strong>, and it ensures that the system doesn’t double-fetch, keeps server and client in sync, and improves performance.</p><h3 id="why-does-it-matter" tabindex="-1"><a class="header-anchor" href="#why-does-it-matter"><span>Why does it matter?</span></a></h3><p>Traditional SSR frameworks often suffer from this trap:</p><ul><li>The server fetches data to render HTML</li><li>The client then re-fetches the <strong>same data</strong> during hydration</li></ul><p>Stone.js avoids that entirely.</p><p>Snapshots are the <strong>bridge between the functional and view dimensions</strong>. They’re what allow SSR apps to feel like SPA apps, <strong>without waste</strong>.</p><p>And the best part? If you return raw data from your page’s <code>handle()</code> method, <strong>Stone.js snapshots it automatically.</strong></p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token string">&#39;Hello from the server!&#39;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// No re-fetch on client, snapshot is restored</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>No extra code, no configuration, no ceremony.</p><h3 id="automatic-snapshotting-in-handle" tabindex="-1"><a class="header-anchor" href="#automatic-snapshotting-in-handle"><span>Automatic Snapshotting in <code>handle()</code></span></a></h3><p>In Stone.js, every page’s <code>handle()</code> method is part of the <strong>functional dimension</strong>. When this method returns raw data, like an object, array, or primitive, and your app is running in <strong>SSR mode</strong>, Stone.js:</p><ol><li>Executes <code>handle()</code> on the server</li><li>Serializes the return value into a <strong>snapshot</strong></li><li>Injects the snapshot into the HTML response</li><li>On the client, during hydration, restores the snapshot to avoid re-fetching</li></ol><p>This means:</p><ul><li>No duplication of data fetching logic</li><li>No extra network requests</li><li>And no mismatch between server-rendered and client-hydrated content</li></ul><h4 id="example" tabindex="-1"><a class="header-anchor" href="#example"><span>Example</span></a></h4><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ProfilePage</span> <span class="token keyword">implements</span> <span class="token class-name">IComponentEventHandler<span class="token operator">&lt;</span>ReactIncomingEvent<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> userService<span class="token operator">:</span> UserService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">async</span> <span class="token function">handle</span><span class="token punctuation">(</span>event<span class="token operator">:</span> ReactIncomingEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userService<span class="token punctuation">.</span><span class="token function">getProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token operator">:</span> RenderContext<span class="token operator">&lt;</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> React<span class="token punctuation">.</span>ReactNode <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>data<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If the page is rendered on the server, the result of <code>handle()</code> is <strong>automatically snapshotted</strong> and <strong>reused on the client</strong>, no need to fetch again.</p><h3 id="manual-snapshotting" tabindex="-1"><a class="header-anchor" href="#manual-snapshotting"><span>Manual Snapshotting</span></a></h3><p>Automatic snapshots work great inside a page’s <code>handle()</code> method, but sometimes, you&#39;re not in <code>handle()</code>.</p><p>You may be fetching data from:</p><ul><li>Middleware</li><li>Route bindings</li><li>Services</li><li>Custom pipelines</li><li>Layouts</li></ul><p>In these cases, <strong>you are responsible</strong> for snapshotting the data manually if you want it to be reused on the client.</p><h4 id="why" tabindex="-1"><a class="header-anchor" href="#why"><span>Why?</span></a></h4><p>Because outside the <code>handle()</code> method, Stone.js has no way of knowing whether the data you&#39;re fetching:</p><ul><li>Needs to be hydrated on the client</li><li>Should be serialized into the HTML</li></ul><div class="hint-container info"><p class="hint-container-title">Info</p><p>Without a manual snapshot, the data will be lost after the server response. And the client will have to re-fetch it.</p></div><h4 id="example-middleware-with-snapshot" tabindex="-1"><a class="header-anchor" href="#example-middleware-with-snapshot"><span>Example: Middleware with snapshot</span></a></h4><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">authMiddleware</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> reactRuntime<span class="token punctuation">,</span> userService <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>event<span class="token operator">:</span> ReactIncomingEvent<span class="token punctuation">,</span> next<span class="token operator">:</span> NextMiddleware<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> reactRuntime<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">  event<span class="token punctuation">.</span><span class="token function">setUserResolver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> user<span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here, the user is fetched once on the server and snapshotted, so it’s already available on the client after hydration.</p><p>Without the <code>snapshot()</code>, the browser would fetch the data again.</p><h3 id="manual-snapshot-techniques" tabindex="-1"><a class="header-anchor" href="#manual-snapshot-techniques"><span>Manual Snapshot Techniques</span></a></h3><p>Stone.js offers <strong>three</strong> ways to manually snapshot data during SSR:</p><h4 id="_1-reactruntime-snapshot" tabindex="-1"><a class="header-anchor" href="#_1-reactruntime-snapshot"><span>1. <code>reactRuntime.snapshot()</code></span></a></h4><p>This is the <strong>recommended and context-aware</strong> method for most use cases.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> reactRuntime<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>What it does:</p><ul><li>Executes the handler if running on the server</li><li>Snapshots the result using a unique key</li><li>On the client, returns the snapshotted value if available</li><li>Falls back to the handler if not</li></ul><p>It is:</p><ul><li>Automatically scoped to the request</li><li>Safe to use in any SSR-aware logic: middleware, layouts, services</li><li>Works in both server and browser</li></ul><h4 id="_2-snapshot-decorator" tabindex="-1"><a class="header-anchor" href="#_2-snapshot-decorator"><span>2. <code>@Snapshot()</code> Decorator</span></a></h4><p>This is the <strong>declarative shortcut</strong> for snapshotting data inside your services.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Service</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> alias<span class="token operator">:</span> <span class="token string">&#39;userService&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Snapshot</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">async</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Stone.js will automatically:</p><ul><li>Generate a stable key based on the method name + arguments</li><li>Snapshot the result during SSR</li><li>Retrieve it from the snapshot store on the client</li></ul><p>It provides:</p><ul><li>Minimal syntax</li><li>Works out of the box in route bindings and services</li><li>You can add your custom unique key name as first argument <code>@Snapshot(&#39;user&#39;)</code></li></ul><h4 id="_3-isnapshot-service" tabindex="-1"><a class="header-anchor" href="#_3-isnapshot-service"><span>3. <code>ISnapshot</code> Service</span></a></h4><p>This is the <strong>low-level API</strong> for accessing the raw snapshot store.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> snapshot <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">make</span><span class="token generic class-name"><span class="token operator">&lt;</span>ISnapshot<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&#39;snapshot&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span></span>
<span class="line">  snapshot<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> user</span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> snapshot<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;user&#39;</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token keyword">await</span> userService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Use this when:</p><ul><li>You need full control over snapshot logic</li><li>You want to write fallback strategies manually</li><li>You’re outside of the React runtime (e.g., background job or system task)</li></ul><p>It provides:</p><ul><li>Maximum control</li><li>You must manage scope, naming, and fallback manually</li><li>Not scoped per request, so take care in SPA mode</li></ul><p>In most cases, prefer <code>reactRuntime.snapshot()</code> or <code>@Snapshot()</code> for simplicity, correctness, and contextual awareness.</p><h3 id="when-to-use-what" tabindex="-1"><a class="header-anchor" href="#when-to-use-what"><span>When to Use What</span></a></h3><p>Depending on where you are in the application lifecycle, different snapshot strategies apply. Here’s a practical guide to help you decide.</p><table><thead><tr><th>Location</th><th>Typical Use Case</th><th>Snapshot Method</th><th>Notes</th></tr></thead><tbody><tr><td><code>handle()</code></td><td>Standard page data fetching</td><td>None (automatic)</td><td>Data is snapshotted by Stone.js</td></tr><tr><td>Middleware</td><td>Auth, guards, route-specific logic</td><td><code>reactRuntime.snapshot()</code></td><td>Must return a full response</td></tr><tr><td>Service</td><td>General-purpose business logic</td><td><code>@Snapshot()</code> decorator</td><td>Use when called from routes, middleware or layout</td></tr><tr><td>Route Binding</td><td>Pre-handler data resolution</td><td><code>@Snapshot()</code> or <code>reactRuntime.snapshot()</code></td><td>Not snapshotted by default</td></tr><tr><td>React Page</td><td>Local state setup</td><td>Use <code>render({ data })</code></td><td>Data already injected from <code>handle()</code></td></tr><tr><td>Component</td><td>Interactive or reactive fetch (client)</td><td>None</td><td>Use <code>useEffect()</code>, no SSR sync</td></tr><tr><td>Layout</td><td>Shared layout data</td><td><code>reactRuntime.snapshot()</code></td><td>Snapshot once, reuse across pages</td></tr></tbody></table><h4 id="key-takeaways" tabindex="-1"><a class="header-anchor" href="#key-takeaways"><span>Key takeaways:</span></a></h4><ul><li>Use <code>handle()</code> for most SSR-friendly data needs, it just works.</li><li>Use <code>reactRuntime.snapshot()</code> when you’re outside of <code>handle()</code> but still in the SSR pipeline.</li><li>Use <code>@Snapshot()</code> when you want automatic snapshotting from your service methods.</li><li>Avoid <code>ISnapshot</code> unless you need complete control.</li></ul><h2 id="state-management" tabindex="-1"><a class="header-anchor" href="#state-management"><span>State Management</span></a></h2><p>Once you’ve fetched data, you often need to hold it somewhere, between components, across views, or through user interaction. That’s where <strong>state management</strong> comes in.</p><p>In Stone.js, state lives in the <strong>View</strong>, not in the functional dimension. Stone.js doesn&#39;t provide its own state system, because React already gives you everything you need.</p><p>You can use:</p><ul><li><code>useState</code>, <code>useReducer</code>, <code>useContext</code> (for local and shared state)</li><li>External tools like Zustand, Redux, or Jotai (manually integrated)</li><li><code>StoneContext</code> for accessing application-wide context (services, event, data)</li></ul><p>But there’s one thing you <strong>shouldn’t do</strong>...</p><h3 id="❌-don-t-use-the-di-container-for-reactive-state" tabindex="-1"><a class="header-anchor" href="#❌-don-t-use-the-di-container-for-reactive-state"><span>❌ Don&#39;t use the DI container for reactive state</span></a></h3><p>The container in Stone.js is <strong>not a state store</strong>.</p><p>It’s designed to resolve and inject <strong>services</strong>, things like authentication, database access, routing, not reactive values.</p><p>Storing mutable state (e.g. current user, UI flags, language) in the container can lead to:</p><ul><li>Memory leaks</li><li>SSR inconsistencies</li><li>Hard-to-track bugs</li><li>Snapshot breakage</li></ul><div class="hint-container important"><p class="hint-container-title">Important</p><p>Use the container to <strong>resolve services</strong>, not to <strong>store values</strong>.</p></div><h3 id="use-stonecontext-for-shared-application-context" tabindex="-1"><a class="header-anchor" href="#use-stonecontext-for-shared-application-context"><span>Use <code>StoneContext</code> for shared application context</span></a></h3><p>The <code>StoneContext</code> is a React context automatically provided by Stone.js. It gives you access to key app-level objects in any React component, <strong>after render</strong>, inside the DOM.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">StoneContextType</span> <span class="token punctuation">{</span></span>
<span class="line">  data<span class="token operator">:</span> <span class="token builtin">any</span>                  <span class="token comment">// Data returned from handle()</span></span>
<span class="line">  container<span class="token operator">:</span> IContainer      <span class="token comment">// Access to services</span></span>
<span class="line">  event<span class="token operator">:</span> ReactIncomingEvent  <span class="token comment">// The current incoming event (browser or server)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>To access it:</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code class="language-tsx"><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> StoneContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@stone-js/use-react&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">ProfileButton</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> event<span class="token punctuation">,</span> container <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>StoneContext<span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">const</span> router <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> router<span class="token punctuation">.</span><span class="token function">navigate</span><span class="token punctuation">(</span><span class="token string">&#39;/profile&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">      Hello, </span><span class="token punctuation">{</span>data<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token plain-text"></span>
<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">Magic</p><p>This lets you stay inside the React ecosystem while still accessing Stone.js context.</p></div><p>You can:</p><ul><li>Use <code>container.resolve(...)</code> to access services</li><li>Read the incoming event (e.g., query parameters, headers)</li><li>Get the <code>data</code> from your page’s <code>handle()</code> method</li></ul><p>All without prop-drilling or breaking encapsulation.</p><h3 id="can-i-use-zustand-redux-or-other-state-libraries" tabindex="-1"><a class="header-anchor" href="#can-i-use-zustand-redux-or-other-state-libraries"><span>Can I use Zustand, Redux, or other state libraries?</span></a></h3><p>Yes! But they are not officially integrated <strong>yet</strong>. You can install them and use them like in any React app:</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">import</span> create <span class="token keyword">from</span> <span class="token string">&#39;zustand&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> useStore <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>set <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">set</span><span class="token punctuation">(</span>state <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You’re also free to create a Stone.js wrapper package (e.g. <code>@stone-js/use-redux</code>) if you want deeper DI or context integration.</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>As always: keep your state <strong>outside Stone.js</strong> and <strong>inside React</strong>.</p></div><h2 id="hydration-in-ssr-and-the-role-of-snapshots" tabindex="-1"><a class="header-anchor" href="#hydration-in-ssr-and-the-role-of-snapshots"><span>Hydration in SSR and the Role of Snapshots</span></a></h2><p>When using <strong>SSR</strong> in Stone.js, rendering happens in <strong>two phases</strong>:</p><ol><li>On the <strong>server</strong>, the page is fully rendered to HTML</li><li>On the <strong>client</strong>, that HTML is <strong>hydrated</strong> into a live React application</li></ol><p>Stone.js handles this entire process for you, no extra configuration required.</p><p>But hydration is not just about the DOM. It&#39;s also about <strong>data continuity</strong> between server and client. That’s where <strong>snapshots</strong> and <strong>StoneContext</strong> come in.</p><h3 id="how-hydration-works-in-stone-js" tabindex="-1"><a class="header-anchor" href="#how-hydration-works-in-stone-js"><span>How hydration works in Stone.js</span></a></h3><p>When a page is requested in SSR mode:</p><ul><li>The <code>handle()</code> method is executed on the server</li><li>The returned data is <strong>snapshotted</strong></li><li>The <code>render()</code> method generates the HTML</li><li>On the client, that HTML is hydrated using React’s <code>hydrateRoot()</code></li><li>Stone.js injects the snapshotted data into the React tree via <code>StoneContext</code></li></ul><p>This avoids:</p><ul><li>Re-fetching data on the client</li><li>UI flickers</li><li>Out-of-sync states between server and browser</li></ul><h3 id="what-apis-are-used-under-the-hood" tabindex="-1"><a class="header-anchor" href="#what-apis-are-used-under-the-hood"><span>What APIs are used under the hood?</span></a></h3><p>Depending on the runtime environment:</p><table><thead><tr><th>Context</th><th>React API used</th></tr></thead><tbody><tr><td>Server (SSR/SOR)</td><td><code>renderToString()</code></td></tr><tr><td>Browser (SSR-hydrate)</td><td><code>hydrateRoot()</code> from <code>react-dom/client</code></td></tr><tr><td>Browser (SPA/CSR)</td><td><code>createRoot()</code></td></tr></tbody></table><p>Stone.js chooses the correct one <strong>based on your adapters</strong> (<code>@Browser</code>, <code>@NodeHttp</code>, etc.).</p><h3 id="what-should-i-do-to-support-hydration" tabindex="-1"><a class="header-anchor" href="#what-should-i-do-to-support-hydration"><span>What should I do to support hydration?</span></a></h3><p>Mostly: <strong>nothing</strong>.</p><p>If you:</p><ul><li>Use <code>handle()</code> to return data</li><li>Use <code>render()</code> to return JSX</li><li>Consume data from the <code>RenderContext</code> or <code>StoneContext</code></li></ul><p>…you’re already hydrated and hydrated correctly.</p><h3 id="lazy-loading-and-hydration" tabindex="-1"><a class="header-anchor" href="#lazy-loading-and-hydration"><span>Lazy loading and hydration</span></a></h3><p>If your page is lazy-loaded (via <code>@Page()</code> or <code>definePage()</code> with <code>lazy: true</code>), Stone.js defers loading the module <strong>until the route is matched</strong>.</p><p>This works with SSR hydration too, only the code needed for the current page is loaded.</p><h3 id="suspense-and-limitations" tabindex="-1"><a class="header-anchor" href="#suspense-and-limitations"><span>Suspense and limitations</span></a></h3><p>Stone.js doesn’t yet implement full Suspense or React Server Components.</p><p>However:</p><ul><li>You can use <code>&lt;Suspense /&gt;</code> in your client-rendered components (CSR or hydrated SSR)</li><li>You cannot use streaming or partial hydration (yet)</li></ul><p>These features may be added in a future release, they require additional adapter-level support.</p><h2 id="best-practices" tabindex="-1"><a class="header-anchor" href="#best-practices"><span>Best Practices</span></a></h2><p>Data fetching in Stone.js is context-aware by design. Here’s how to use it effectively across SSR, SOR, and SPA applications.</p><h4 id="use-handle-for-initial-data" tabindex="-1"><a class="header-anchor" href="#use-handle-for-initial-data"><span>Use <code>handle()</code> for initial data</span></a></h4><p>If your data is required at page load time, the cleanest place to fetch it is in the <code>handle()</code> method of your page.</p><ul><li>It’s automatically snapshotted in SSR</li><li>It integrates with the lifecycle</li><li>It’s passed to the <code>render()</code> method via <code>RenderContext.data</code></li></ul><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token function">handle</span><span class="token punctuation">(</span>event<span class="token operator">:</span> ReactIncomingEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>profileService<span class="token punctuation">.</span><span class="token function">getCurrentUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="use-reactruntime-snapshot-outside-handle" tabindex="-1"><a class="header-anchor" href="#use-reactruntime-snapshot-outside-handle"><span>Use <code>reactRuntime.snapshot()</code> outside <code>handle()</code></span></a></h4><p>If you’re in middleware, a layout, or a service that runs outside the page handler:</p><ul><li>Use <code>reactRuntime.snapshot()</code> to avoid double-fetching in SSR</li><li>Scope your key carefully (e.g. <code>&#39;user.profile&#39;</code>, <code>&#39;auth.token&#39;</code>)</li></ul><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> profile <span class="token operator">=</span> <span class="token keyword">await</span> reactRuntime<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token string">&#39;user.profile&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>profileService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="use-the-snapshot-decorator-for-services" tabindex="-1"><a class="header-anchor" href="#use-the-snapshot-decorator-for-services"><span>Use the <code>@Snapshot()</code> decorator for services</span></a></h4><p>Want to hide the snapshot logic entirely? Use the decorator, ideal for services used in route bindings or middlewares.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token decorator"><span class="token at operator">@</span><span class="token function">Snapshot</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userRepository<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="don-t-fetch-in-components-if-you-need-ssr-sync" tabindex="-1"><a class="header-anchor" href="#don-t-fetch-in-components-if-you-need-ssr-sync"><span>Don’t fetch in components if you need SSR sync</span></a></h4><p>Components rendered via React don’t run until the client is live. That means <code>useEffect()</code> fetches will never be snapshotted.</p><p>Use component fetches only for:</p><ul><li>Reactive state</li><li>Interactive behavior</li><li>Client-only concerns</li></ul><h4 id="use-stonecontext-to-access-services" tabindex="-1"><a class="header-anchor" href="#use-stonecontext-to-access-services"><span>Use <code>StoneContext</code> to access services</span></a></h4><p>Avoid passing the container or router manually into components. Instead, use:</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> <span class="token punctuation">{</span> container <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>StoneContext<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">const</span> router <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>This ensures your components remain portable and loosely coupled to the framework.</p><h4 id="never-use-the-service-container-for-reactive-state" tabindex="-1"><a class="header-anchor" href="#never-use-the-service-container-for-reactive-state"><span>Never use the service container for reactive state</span></a></h4><p>The service container is for:</p><ul><li>Instantiating services</li><li>Providing architectural structure</li><li>Managing shared stateless dependencies</li></ul><p>It is not designed for global mutable state.</p><p>Use React’s own tools (<code>useState</code>, <code>useReducer</code>, or libraries like Zustand) for reactive client state.</p><h4 id="snapshot-only-when-needed" tabindex="-1"><a class="header-anchor" href="#snapshot-only-when-needed"><span>Snapshot only when needed</span></a></h4><p>If your data is:</p><ul><li>Fetched in <code>handle()</code> → already snapshotted ✅</li><li>Used only on the server → no need to snapshot ❌</li><li>Used across SSR boundary → use snapshot() or <code>@Snapshot()</code> ✅</li><li>Never snapshot sensitive data (e.g. passwords, tokens) ❌</li><li>Avoid snapshotting large objects or arrays unnecessarily ❌</li></ul><div class="hint-container important"><p class="hint-container-title">Important</p><p>Snapshotting too much can bloat HTML and affect hydration performance.<br> So be mindful of what you snapshot and don&#39;t overdo it.</p></div><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>Stone.js provides a unified, context-aware approach to data fetching that adapts to all dimensions, SSR, CSR, and SOR, without requiring separate strategies or mental models.</p><p>Thanks to the Continuum Architecture:</p><ul><li>You can fetch data in the <strong>functional dimension</strong> using <code>handle()</code> or services.</li><li>You can render it in the <strong>view dimension</strong> using React components.</li><li>And you can hydrate it <strong>automatically</strong> through snapshots, bridging both worlds.</li></ul><h3 id="key-takeaways-1" tabindex="-1"><a class="header-anchor" href="#key-takeaways-1"><span>Key takeaways:</span></a></h3><ul><li>Use <code>handle()</code> to fetch data for your pages, it will be snapshotted in SSR.</li><li>Use <code>reactRuntime.snapshot()</code> in middleware, layouts, or services when needed.</li><li>Use the <code>@Snapshot()</code> decorator to snapshot service methods transparently.</li><li>Use <code>StoneContext</code> to access runtime context in React components.</li><li>Don&#39;t use the container for reactive state, keep state local or use a store.</li><li>Lazy loading works seamlessly with data fetching and hydration.</li></ul><p>Stone.js does not reinvent data fetching, it simplifies it by aligning it with architectural boundaries and runtime awareness.</p><p>When you fetch, render, and hydrate in sync, your app feels seamless. That’s not just SSR done right, it’s the <strong>continuum in action</strong>.</p>`,179)]))}const r=s(o,[["render",p]]),d=JSON.parse(`{"path":"/docs/react/fetching.html","title":"Data Fetching","lang":"en-US","frontmatter":{"title":"Data Fetching","description":"Data is the lifeblood of most applications. Whether it's coming from a database, an API, or a service layer, Stone.js gives you multiple ways to fetch, inject, and reuse data, a...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Data Fetching\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-07T20:31:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr. Stone\\"}]}"],["meta",{"property":"og:url","content":"https://stonejs.com/docs/react/fetching.html"}],["meta",{"property":"og:site_name","content":"Stone.js"}],["meta",{"property":"og:title","content":"Data Fetching"}],["meta",{"property":"og:description","content":"Data is the lifeblood of most applications. Whether it's coming from a database, an API, or a service layer, Stone.js gives you multiple ways to fetch, inject, and reuse data, a..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-06-07T20:31:21.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-07T20:31:21.000Z"}]]},"git":{"createdTime":1749328281000,"updatedTime":1749328281000,"contributors":[{"name":"Mr Stone","username":"","email":"pierre.evens16@gmail.com","commits":1}]},"readingTime":{"minutes":8.69,"words":2606},"filePathRelative":"docs/react/fetching.md","autoDesc":true}`);export{r as comp,d as data};
